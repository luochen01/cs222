1. Basic information
Student ID : 51288702
Student Name : Chen Luo
OS (bit) :  64, Ubuntu 16.04.02
gcc version : 5.4.0


2. Internal Record Format
- Show your record format design and describe how your design satisfies O(1) field access. If not, just mention that you haven't implemented this feature.
- Describe how you store a VarChar field.

I used an offset-table based format to store each record. Specially, a record with N fields is stored as follows:

offset1, offset2, ..., offsetN, field1, field2, ..., fieldN

An offset table containing N offsets (each takes 2 bytes) is placed at the beginning of the record, where the ith offset indicates the end offset of the ith field. Thus, the start offset of the ith field is simply the end address of the previous field, i.e., offset i-1. In particular, for the first field, its start offset is just the end offset of the offset table, i.e., offset0 = N * 2.
If a field is NULL, then its corresponding end offset is just set as its start offset.

To access the ith field, one first needs to access the i-1th and ith item in the offset table (note offset0 can be implicitly computed) to get the start and end offset of that field. Then, the ith field can be retrieved by accessing record data between offseti-1 and offseti. Note if offseti-1 equals to offseti, which indicates the field is NULL, then the memory read operation can be simply skipped.

Given a VarChar field with size N, its size N is stored in 2 bytes, followed by the actual N bytes of the field.


3. Page Format
- Show your page format design

The format of each page is as follows:

recordStartOffset, slotSize, slot1, slot2, ..., slot n,  ..., free space, ..., recordn, ..., record1

The first two variables, each takes 2 bytes, store metadata about this page. Variable recordStartoffset stores the offset where the record space starts, and variable slotSize stores the size of the record slot table. After these two variables comes the record slot table. Each record slot contains two variables, which are offset and size, and each takes 2 bytes. Offset stores the start offset of the corresponding record, while size stores the size of that record. The records are stored at the end of the page, and grow in the reverse direction. The free space is between the record table and the record space, and it is used up when the end of the slot table meets the start of the record space.


The organization of all pages in a file is as follows:

numPages, page1, ..., pageN

The file header only contains a variable numPages, which takes 4 bytes and stores the number of pages in the file. The pages are then stored after the file header. To locate the ith page, one can simply calculate its start address as 4 + PAGE_SIZE * i, where PAGE_SIZE is 4096. For simplicity, the metadata of each page, such as the available space, is not stored in the current implementation, since no deletion is performed on the page. However, this may be extended in the future implementation.


4. Implementation Detail
- Other implementation details goes here.
In my implementation, I added several classes in correspondence to the design of the file/page/record format. The data from the file system is first loaded into the objects of these classes, operations can then be performed on these objects, and finally the objects are written back into the file system. These classes are briefly explained as follows.

Record: corresponds to each record stored in the page, and provides methods for reading/writing fields and the entire record.
RecordSlot: corresponds to the record slot in the page.
RecordPage: corresponds to a page which stores records, and provides methods for reading/writing the slot table and records.

5. Other (optional)
- Freely use this section to tell us about things that are related to the project 1, but not related to the other sections (optional)
I also added two extra files, which are util.h and util.cc. These two files provide utility functions, such as reading/writing memories and bit operations etc.

Another test case, named rbftestlc1, is also added into the project.


